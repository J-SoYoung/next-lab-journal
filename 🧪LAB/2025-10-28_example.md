# useEffect vs Server Component (2024-11-09)
## 0. Context
- 강의: 섹션3 2.18 사전 렌더링과 데이터패칭
## 1. Hypothesis
- SSR에서는 useEffect 내부 코드가 실행되지 않을 것이다.
## 2. Method
- getServerSideProps에서 데이터 fetch 후, useEffect로 console.log 시점 비교
## 3. Result
- 서버 콘솔: 없음 / 브라우저 콘솔: 렌더 후 실행됨.
## 4. Insight
- SSR 단계에서는 React 훅이 작동하지 않는다.
- 즉, useEffect는 오직 “hydration 이후”에만 의미가 있다.
## 5. Action
- 데이터 fetching 로직을 useEffect에서 Server Action으로 이동.

---------
# SSG fallback 옵션 비교 (true / blocking / false) - 2024-11-19
## 0. Context
- 강의: 섹션3 2.15~2.16
- 코드: /products/[id] with getStaticPaths

## 1. Hypothesis
- fallback 'blocking'은 첫 방문 대기 시간이 길지만, 사용자는 로딩 UI를 보지 않는다.
- fallback 'true'는 로딩 UI가 보이지만 최초 진입이 더 빠를 수 있다.

## 2. Method
- 네트워크 Slow 3G, 캐시 비활성
- id = 'new-123' (빌드 시 미생성)
- 측정: 첫 컨텐츠 표시, 로딩 UI 노출 여부, 사용자 체감 피드백(내 체감 기록)

## 3. Result
- blocking: 로딩UI 없음, 최초 진입 2.1s, 체감 "멈춘 듯-완성" 느낌
- true: 로딩UI 0.8s 노출 후 컨텐츠 2.0s, 체감 "부드럽게 로딩"
- false: 404 즉시

## 4. Insight
- UX 관점: 컨텐츠 신뢰가 중요하면 blocking, 진행감이 중요하면 true.
- 내 서비스(문화공연)는 true가 더 자연스러움.

## 5. Action
- Culture Friend는 fallback 'true' 채택 + Skeleton 강도 ↑
- 2주 뒤 실제 사용자 피드백 수집 예정

## 6. AI Review Log
- Prompt: "SSG fallback UX 차이를 인터뷰에서 설득력 있게 설명하는 3단계 논리"
- Suggestion: 1) 사용 시나리오 정의 2) 체감/수치 병행 3) 리스크/완화책
- 채택: 전부
